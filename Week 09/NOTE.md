# 学习笔记 | 浏览器工作原理  (html-parse/)

## 1. HTML 解析 | HTML parser 模块的文件拆分  

  ![浏览器阶段到了完成 HTML 解析环节](img/week09-1.png)

  [代码实现](html-parse/1-splitFile/)：实现 HTML 的 parse 模块，做成分段处理。

  第一步总结

  * 为了方便文件管理，把 parser 单独拆到文件中
  * parser 接受 HTML 文本作为参数，返回一颗 DOM 树

## 2. HTML 解析 | 用 FSM 实现 HTML 的分析

  [HTML语法](https://html.spec.whatwg.org/multipage/)：在 HTML 标准里面，已经把整个的状态机给设计好了，所以可以直接看到 HTML 标准里面设计好的状态机。

  [代码实现](html-parse/2-initFSM/)：初始状态，对 html 里面每个字符循环，然后去调用这个状态机里面 state 的操作。

  第二步总结
  
  * 我们用 FSM 来实现 HTML 的分析
  * 在 HTML 标准中，已经规定了 HTML 的状态
  * Toy-Browser 只挑选其中一部分状态，完成一个最简版本

## 3. HTML 解析 | 解析标签

  [代码实现](html-parse/3-parseTag/)：真正的把状态机里面的状态写出来一部分，然后尝试去把 HTML 里面的所有的 tag 做一个分析。

  第三步总结

  * 主要的标签有：开始标签，结束标签和自封闭标签
  * 在这一步暂时忽略属性

## 4. HTML 解析 | 创建元素

  [代码实现](html-parse/4-emitToken/)：创建元素，在状态机里面加入计算逻辑，也就是状态及存在的意义，增加逻辑区处理业务。

  第四步总结

  * 在状态机中，除了状态迁移，还会要加入业务逻辑
  * 在标签结束状态提交标签 token

## 5. HTML 解析 | 处理属性

  [代码实现](html-parse/5-attribute/)：进行词法分析的最后一个步骤，展现一些状态的使用技巧和一些 HTML 的解析比较特有的地方，把属性相关的状态机补全，加入逻辑，再把属性挂到 startTag 上。

  第五步总结

  * 属性值分为单引号、双引号、无引号三种写法，因此需要较多状态处理
  * 处理属性的方式跟标签类似
  * 属性结束时，把属性加到标签 Token 上

## 6. HTML 解析 | 用 token 构建 DOM 树

  [代码实现](html-parse/6-constructTree)：接下来就是 HTML 的语法分析，包括各个不同层级结构，然后学习如何用已经准备好的 token 去构建一棵 DOM 树。
  
  第六步总结

  * 从标签构建 DOM 树的基本技巧是使用栈
  * 遇到开始标签时创建元素并入栈，遇到结束标签时出栈
  * 自封闭节点可视为入栈后立刻出栈
  * 任何元素的父元素是它入栈前的栈顶

## 7. HTML 解析 | 将文本节点加到 DOM树

  [代码实现](html-parse/7-combine/)：补全在 constructTree 阶段的一个小瑕疵，把文本节点加到 DOM 树当中去。

  第七步总结

  * 文本节点与自封闭标签处理类似
  * 多个文本节点需要合并

## 8. CSS 计算 | 收集 CSS 规则

  [代码实现]()：通过 CSS 计算来生成一棵带 CSS 属性的 DOM 树。

  **CSS Computing**：把 CSS 规则里头所包含的那些 CSS 属性应用到匹配这些选择器的元素上去。

  ![浏览器阶段到了完成 构建 DOM CSS Computing 环节](img/week09-2.png)
  <br/>
  <br/>

  ### 环境准备

    npm install CSS

  [代码实现](css-computing/1/)：此时需要对 CSS 进行语法喝词法分析，用 npm 上一个现成的包 css，也就是 CSS parser 可以帮助完成把 CSS 的代码变成 AST 抽象语法树这样的一个过程，会极大的降低工作量。我们所要做的就是根据这棵抽象语法树来抽出各种 CSS 规则，并且应用到 HTML 元素上。

  **CSS Computing**：CSS Computing 整个过程其实是发生在 DOM 树构建的时候。

  第一步总结

  * 遇到 style 标签时，把 CSS 规则保存起来
  * 这里调用 CSS Parser 来分析 CSS 规则
  * 这里必须要仔细研究此库分析 CSS 规则的格式

## 9. CSS 计算 | 添加调用

  [代码实现](css-computing/2/)：把 CSS 规则给应用上去，应用的时机越早越好。

  第二步总结：

  * 当创建一个元素后，立即计算 CSS
  * 理论上，当分析一个元素时，所有 CSS 规则已经收集完毕
  * 在真实浏览器中，可能遇到写在 body 的 style 标签，需要重新 CSS 计算的清空，这里由于是 toy-browser 忽略。

## 10. CSS 计算 | 获取父元素序列

  [代码实现](css-computing/3/)：为什么要获取父元素系列？因为选择器大多数都是跟元素的父元素相关的。

  第三部总结：

  * 在 computeCSS 函数中，必须知道元素的所有父元素才能判断元素与规则是否匹配
  * 从上一步的 stack ，可以获取本元素所有的父元素
  * 因为首先获取的是“当前元素”，所有获得和计算父元素匹配的顺序是从内向外

    > ### 例子：div div #myid
    > 
    > ![比如小栗子](img/week09-3.png)
    >
    > 前面两个 div 这两个选择器因为是用空格，所以是一个子孙选择器，由于不确定这两个 div 到底要跟哪个父元素匹配，而最后一个 myid 的元素是一定会跟当前元素相匹配的。
    >
    > 所以要想高效的去实现一个 CSS 选择器的匹配规则，一定是先去检查最后一个 myid 选择器，不管是什么选择器。
    >
    > 所以这里计算父元素的匹配顺序就都是会从内向外。

## 11. CSS 计算 | 选择器与元素匹配

  [代码实现](css-computing/4/)：处理选择器跟元素的匹配问题，对复杂选择器根据空格进行一下拆分。

  **选择器**：有一个层级结构，最外层的叫选择器列表，CSS parser 已经帮我们做了拆分；选择器列表里边的叫做复杂选择器，复杂选择器是由空格分割的一系列复合选择器，根据亲代关系，然后去选择元素；复合选择器针对一个元素的本身的属性和特征的一个判断，由紧连着一堆的简单选择器而构成的。

  第四部总结

  * 选择器也要从当前元素向外排列
  * 复杂选择器拆成针对单个元素的选择器，用循环匹配父元素队列（一个两个数组同时进行的一个循环，这块的算法算是整个的选择器的匹配算法里面的一个小小的难点，多钻研）

## 12. CSS 计算 | 计算选择器与元素匹配

  [代码实现](css-computing/5/)：计算选择器与元素匹配，实现 match 函数里面的内容。

  第五步总结

  * 根据选择器的类型和元素属性，计算是否与当前元素匹配
  * 这里仅仅实现了三种基本选择器，实际的浏览器中要处理复合选择器
  * 作业：实现复合选择器，实现支持空格的 Class 选择器
## 13. CSS 计算 | 生成 computed 属性

  [代码实现](css-computing/6/)：最后把 compute 的属性生成，把 CSS rules 里面声明的属性一条一条的作用到元素的 compute 的属性上面。

  第六步总结

  * 一旦选择匹配，就应用选择器到元素上，形成 computedStyle

## 14. CSS 计算 | specificity 的计算逻辑

  [代码实现](css-computing/7/)：完成 specificity 的计算逻辑，到这一步就完成了带 specificity 的 CSS Computing。

    specificity 的计算是根据单个的复杂选择器去加起来计算的；specificity 是一个四元组，左边是优先级最高的一位

    div div #id
    [0,     1,      0,      2]
    inline  id      class   tag

    inline：inline 的位置就是所有的写在 style 属性上面的 CSS 属性这个优先级都是 1

    div #id
    [0,     1,      0,      1]

    两个选择器作比较：如果它们有相同的属性的话，那么上面的这条规则就会覆盖下面这条规则

  第七步总结

  * CSS 规则根据 specificity 和后来优先规则覆盖
  * specificity 是个四元组，越左边权重越高
  * 一个 CSS 规则的 specificity 根据包含的简单选择器相加而成

<br/>
<br/>

### 从最开始的 URL 经过 HTTP 模块拿到 HTML 代码，又从 HTML 代码进行 parse 得到了 DOM，现在把一棵光秃秃的 DOM 树上加上了渲染所需要的 CSS 属性。
![浏览器已经完成了 DOM CSS Computing 的计算逻辑](img/week09-4.png)