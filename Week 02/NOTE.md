# 学习笔记
## 寻路算法
  > 什么是寻路：**寻路是一个广度优先搜索算法**

  - 介绍
  
    - 有 *UI* 的部分、有一些 *JavaScript* 特有的跟语言特性结合的部分
    * 寻路的问题：是在一张地图上，100*100，定义起点和终点，通过横竖斜各个方向去找到通往终点的路径
      - 横竖的路径
      * 斜向的路径：存在一定的差异，尤其是在地图比较空旷的情况下
    - 广度优先搜索：访问周围的时候是完全依照着访问的顺序来决定哪个是最短路径
  
  * 思路
    - 实现一个地图编辑器
      * 100 * 100 的地图网格
      - 选用一维数组
      * 初始化10000的数组

    * 广度优先搜索（结合index.png）
      - 第一步：从起点我们能走到哪里去？
        * 上下左右四个点如果没有障碍那么就可以走过去
        - 假如走到了1234 4个点之后，是不是又能走到1234相邻的点呢？
        * 从起点能走到哪？就是把能走到的点的周围的点加进这个能走到的集合里面的一个过程
          - 比如指定好了1234 4个点，从蓝色的起点的格能走到1234 4个点
          * 那么从1又能走到哪呢？于是得到了567 3个点。因为已经能走过的点就不再把它重复的数进来
          - 把2所有能走到的点加进来，于是有了89
          * 把3能走到的点加进来，于是有了10 11
          - 把4能走到的点进来，又有了12，最后又有了新的一层紫色的格...
          > ***集合：所有搜索算法的灵魂，所有搜索算法的差异部分完全就在于这个queue集合里面***
      
      * 第二布：把56789 10 11 12这些点再次重复刚才的动作，看能够走到哪去
        > 遇到边或障碍物，这个点就走不过去<br>
        > **注意**：此方法并不适用递归。它肯定会从1找到这个1开始，它就开始找1的周围的点，那么5 6 7可能会在2 3 4前面被执行，因为是递归，逐层展开，如果这个过程默认用递归的方式表达会变成一个深度优先搜索。对于寻路问题来说，深度优先搜索是不适用的，更适合用广度优先搜索。 
    - 通过异步编程可视化寻路算法
      * 问题：
        - 算法：虽然返回了true看起来符合了预期，但是正确性不太好保证
        * 要找到一条路径，并没有找到能不能走过去
        - 无法调试：可视化方法 async/await
    * 处理路径问题
      > 根据 *index.png* ，会发现其实在扩展每个点的时候是从哪个点来的，比如：567 的前一个节点是 1 、 89 从 2 扩展来的，在执行insert的时候会发现它的前一个点是什么。<br>
      > 那么怎么样寻找最终的路径？只要把那个标在  map 上标 2 的过程改成标它的前驱节点的过程。<br>
      > 比如：执行 8 这个点的时候，把2这个点的坐标写到 8 的位置就结束了
    - 启发式搜素(一)
    * 启发式搜索(二)
    - 二叉堆


  * 方法
    - ***fill()*** 用一个固定值填充一个数组中从起始索引到终止索引内的全部元素，不包括终止索引
    * ***mousemove*** 当指针设备在元素上移动时
    - ***mousedown*** 事件在指针设备按钮按下时触发
    * ***mouseup*** 事件在指针设备按钮放开时触发
    - ***contextmenu*** 鼠标点击右键或者按下键盘上的菜单键时被触发
  
  * 小技巧
    - `map[y * 100 + x]`： 找到在地图相对应的位置，用一维数字来来表示二维矩阵
  * 思考
    - *JavaScript* 里面有 *queue* 这个数据结构吗？
      > *JavaScript* 的数组是一个天然的队列和一个天然的栈。有 *shift* 、*unshift* 和 *push* 、*pop* 两组方法。<br>
      > 如果 *push* 跟 *shift* 相对，那么它就是一个队列<br>
      > *pop* 跟 *unshift* 联合使用，也是一个队列
      <br>
      > 如果 *push* 和 *pop* 作为一组来使用，那么它就是一个栈
      <br>
      > *shift* 和 *unshift* 同理 栈  不考虑  性能低